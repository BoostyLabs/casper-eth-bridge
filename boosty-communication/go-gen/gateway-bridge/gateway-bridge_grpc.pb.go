// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: gateway-bridge/gateway-bridge.proto

package pb_gateway_bridge

import (
	context "context"
	networks "github.com/BoostyLabs/casper-eth-bridge/boosty-communication/go-gen/networks"
	transfers "github.com/BoostyLabs/casper-eth-bridge/boosty-communication/go-gen/transfers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GatewayBridgeClient is the client API for GatewayBridge service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayBridgeClient interface {
	// Return a list of all networks this bridge is connected to.
	ConnectedNetworks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*networks.ConnectedNetworksResponse, error)
	// Return a list of all tokens supported by particular network.
	SupportedTokens(ctx context.Context, in *networks.SupportedTokensRequest, opts ...grpc.CallOption) (*networks.TokensResponse, error)
	// Estimate a potential transfer.
	EstimateTransfer(ctx context.Context, in *transfers.EstimateTransferRequest, opts ...grpc.CallOption) (*transfers.EstimateTransferResponse, error)
	// Return status of transfer.
	Transfer(ctx context.Context, in *transfers.TransferRequest, opts ...grpc.CallOption) (*transfers.TransferResponse, error)
	// Cancel a pending transfer.
	CancelTransfer(ctx context.Context, in *transfers.CancelTransferRequest, opts ...grpc.CallOption) (*transfers.CancelTransferResponse, error)
	// Return paginated transfer history for user.
	TransferHistory(ctx context.Context, in *transfers.TransferHistoryRequest, opts ...grpc.CallOption) (*transfers.TransferHistoryResponse, error)
	// Return signature for user to send bridgeIn transaction.
	BridgeInSignature(ctx context.Context, in *transfers.BridgeInSignatureRequest, opts ...grpc.CallOption) (*transfers.BridgeInSignatureResponse, error)
}

type gatewayBridgeClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayBridgeClient(cc grpc.ClientConnInterface) GatewayBridgeClient {
	return &gatewayBridgeClient{cc}
}

func (c *gatewayBridgeClient) ConnectedNetworks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*networks.ConnectedNetworksResponse, error) {
	out := new(networks.ConnectedNetworksResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/ConnectedNetworks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayBridgeClient) SupportedTokens(ctx context.Context, in *networks.SupportedTokensRequest, opts ...grpc.CallOption) (*networks.TokensResponse, error) {
	out := new(networks.TokensResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/SupportedTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayBridgeClient) EstimateTransfer(ctx context.Context, in *transfers.EstimateTransferRequest, opts ...grpc.CallOption) (*transfers.EstimateTransferResponse, error) {
	out := new(transfers.EstimateTransferResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/EstimateTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayBridgeClient) Transfer(ctx context.Context, in *transfers.TransferRequest, opts ...grpc.CallOption) (*transfers.TransferResponse, error) {
	out := new(transfers.TransferResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/Transfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayBridgeClient) CancelTransfer(ctx context.Context, in *transfers.CancelTransferRequest, opts ...grpc.CallOption) (*transfers.CancelTransferResponse, error) {
	out := new(transfers.CancelTransferResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/CancelTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayBridgeClient) TransferHistory(ctx context.Context, in *transfers.TransferHistoryRequest, opts ...grpc.CallOption) (*transfers.TransferHistoryResponse, error) {
	out := new(transfers.TransferHistoryResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/TransferHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayBridgeClient) BridgeInSignature(ctx context.Context, in *transfers.BridgeInSignatureRequest, opts ...grpc.CallOption) (*transfers.BridgeInSignatureResponse, error) {
	out := new(transfers.BridgeInSignatureResponse)
	err := c.cc.Invoke(ctx, "/golden_gate.GatewayBridge/BridgeInSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayBridgeServer is the server API for GatewayBridge service.
// All implementations should embed UnimplementedGatewayBridgeServer
// for forward compatibility
type GatewayBridgeServer interface {
	// Return a list of all networks this bridge is connected to.
	ConnectedNetworks(context.Context, *emptypb.Empty) (*networks.ConnectedNetworksResponse, error)
	// Return a list of all tokens supported by particular network.
	SupportedTokens(context.Context, *networks.SupportedTokensRequest) (*networks.TokensResponse, error)
	// Estimate a potential transfer.
	EstimateTransfer(context.Context, *transfers.EstimateTransferRequest) (*transfers.EstimateTransferResponse, error)
	// Return status of transfer.
	Transfer(context.Context, *transfers.TransferRequest) (*transfers.TransferResponse, error)
	// Cancel a pending transfer.
	CancelTransfer(context.Context, *transfers.CancelTransferRequest) (*transfers.CancelTransferResponse, error)
	// Return paginated transfer history for user.
	TransferHistory(context.Context, *transfers.TransferHistoryRequest) (*transfers.TransferHistoryResponse, error)
	// Return signature for user to send bridgeIn transaction.
	BridgeInSignature(context.Context, *transfers.BridgeInSignatureRequest) (*transfers.BridgeInSignatureResponse, error)
}

// UnimplementedGatewayBridgeServer should be embedded to have forward compatible implementations.
type UnimplementedGatewayBridgeServer struct {
}

func (UnimplementedGatewayBridgeServer) ConnectedNetworks(context.Context, *emptypb.Empty) (*networks.ConnectedNetworksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectedNetworks not implemented")
}
func (UnimplementedGatewayBridgeServer) SupportedTokens(context.Context, *networks.SupportedTokensRequest) (*networks.TokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SupportedTokens not implemented")
}
func (UnimplementedGatewayBridgeServer) EstimateTransfer(context.Context, *transfers.EstimateTransferRequest) (*transfers.EstimateTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateTransfer not implemented")
}
func (UnimplementedGatewayBridgeServer) Transfer(context.Context, *transfers.TransferRequest) (*transfers.TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedGatewayBridgeServer) CancelTransfer(context.Context, *transfers.CancelTransferRequest) (*transfers.CancelTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTransfer not implemented")
}
func (UnimplementedGatewayBridgeServer) TransferHistory(context.Context, *transfers.TransferHistoryRequest) (*transfers.TransferHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferHistory not implemented")
}
func (UnimplementedGatewayBridgeServer) BridgeInSignature(context.Context, *transfers.BridgeInSignatureRequest) (*transfers.BridgeInSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BridgeInSignature not implemented")
}

// UnsafeGatewayBridgeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayBridgeServer will
// result in compilation errors.
type UnsafeGatewayBridgeServer interface {
	mustEmbedUnimplementedGatewayBridgeServer()
}

func RegisterGatewayBridgeServer(s grpc.ServiceRegistrar, srv GatewayBridgeServer) {
	s.RegisterService(&GatewayBridge_ServiceDesc, srv)
}

func _GatewayBridge_ConnectedNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).ConnectedNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/ConnectedNetworks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).ConnectedNetworks(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayBridge_SupportedTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(networks.SupportedTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).SupportedTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/SupportedTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).SupportedTokens(ctx, req.(*networks.SupportedTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayBridge_EstimateTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transfers.EstimateTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).EstimateTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/EstimateTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).EstimateTransfer(ctx, req.(*transfers.EstimateTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayBridge_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transfers.TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/Transfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).Transfer(ctx, req.(*transfers.TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayBridge_CancelTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transfers.CancelTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).CancelTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/CancelTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).CancelTransfer(ctx, req.(*transfers.CancelTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayBridge_TransferHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transfers.TransferHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).TransferHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/TransferHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).TransferHistory(ctx, req.(*transfers.TransferHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayBridge_BridgeInSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transfers.BridgeInSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayBridgeServer).BridgeInSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/golden_gate.GatewayBridge/BridgeInSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayBridgeServer).BridgeInSignature(ctx, req.(*transfers.BridgeInSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayBridge_ServiceDesc is the grpc.ServiceDesc for GatewayBridge service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayBridge_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "golden_gate.GatewayBridge",
	HandlerType: (*GatewayBridgeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConnectedNetworks",
			Handler:    _GatewayBridge_ConnectedNetworks_Handler,
		},
		{
			MethodName: "SupportedTokens",
			Handler:    _GatewayBridge_SupportedTokens_Handler,
		},
		{
			MethodName: "EstimateTransfer",
			Handler:    _GatewayBridge_EstimateTransfer_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _GatewayBridge_Transfer_Handler,
		},
		{
			MethodName: "CancelTransfer",
			Handler:    _GatewayBridge_CancelTransfer_Handler,
		},
		{
			MethodName: "TransferHistory",
			Handler:    _GatewayBridge_TransferHistory_Handler,
		},
		{
			MethodName: "BridgeInSignature",
			Handler:    _GatewayBridge_BridgeInSignature_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gateway-bridge/gateway-bridge.proto",
}
